# üîç Analyseur d'Imports - Int√©gration TemporalFractalMemoryEngine

**Date de cr√©ation :** 2025-08-06 15:45:30  
**Auteur :** Alma (via Lucie Defraiteur)  
**Contexte :** Int√©gration de l'analyseur d'imports dans le nouveau TemporalFractalMemoryEngine

---

## üìÅ **Emplacement et Structure**

### Script Principal
- **Fichier :** `UnitTests/partitioning_import_analyzer.py`
- **Fonction :** Analyse r√©cursive des d√©pendances Python avec d√©tection de cycles
- **G√©n√©ration :** Rapports Markdown et JSON d√©taill√©s

### Composants Cl√©s
1. **`PartitioningImportAnalyzer`** - Classe principale d'analyse
2. **`SimpleImportAnalyzerLogger`** - Syst√®me de logging et g√©n√©ration de rapports
3. **`DependencyGraph`** - Graphe de d√©pendances avec d√©tection de cycles
4. **`_generate_ascii_tree()`** - G√©n√©ration d'arbre ASCII structurel

---

## üöÄ **Utilisation Actuelle**

### Commandes Principales
```bash
# Analyse compl√®te avec logs
python UnitTests/partitioning_import_analyzer.py --local-only --log-output --log-directory logs --log-format json --no-import-resolver

# Avec ImportResolver activ√©
python UnitTests/partitioning_import_analyzer.py --local-only --log-output --use-import-resolver

# Avec limite de profondeur
python UnitTests/partitioning_import_analyzer.py --max-depth 3 --log-output
```

### Fonctionnalit√©s
- ‚úÖ **Analyse r√©cursive pure** jusqu'√† la profondeur maximale
- ‚úÖ **D√©tection de cycles intelligente** avec pr√©vention
- ‚úÖ **R√©solution d'imports** (simple + ImportResolver)
- ‚úÖ **G√©n√©ration de rapports** Markdown structur√©s
- ‚úÖ **Arbre ASCII** de la hi√©rarchie des fichiers
- ‚úÖ **Statistiques d√©taill√©es** par type d'import

### Sorties G√©n√©r√©es
- **Rapport Markdown :** `logs/imports_analysis/imports_analysis_report.md`
- **Log JSON :** `logs/imports_analysis/imports_analysis.log`
- **Structure :** Liste simple ‚Üí Arbre ASCII ‚Üí D√©tails ‚Üí Stats

---

## üß† **Int√©gration dans TemporalFractalMemoryEngine**

### Vision Conceptuelle

L'analyseur d'imports peut devenir un **"FractalImportMapper"** qui transforme les relations d'imports en **liens fractaux temporels**, cr√©ant une cartographie vivante des d√©pendances du projet.

### Architecture Propos√©e

#### 1. **FractalImportNode** (Nouvelle classe)
```python
@dataclass
class FractalImportNode:
    """N≈ìud fractal repr√©sentant un fichier et ses imports"""
    
    # Identifiants
    file_path: str
    fractal_uuid: str = field(default_factory=lambda: str(uuid.uuid4()))
    temporal_timestamp: datetime = field(default_factory=datetime.now)
    
    # Relations fractales
    import_links: List[FractalImportLink] = field(default_factory=list)
    dependency_depth: int = 0
    import_complexity: float = 0.0  # M√©trique de complexit√©
    
    # Strates temporelles
    strata: str = "cognitive"  # cognitive, temporal, fractal
    temporal_links: List[TemporalLink] = field(default_factory=list)
    
    # M√©tadonn√©es fractales
    fractal_dimensions: Dict[str, Any] = field(default_factory=dict)
    import_patterns: List[str] = field(default_factory=list)
```

#### 2. **FractalImportLink** (Nouvelle classe)
```python
@dataclass
class FractalImportLink:
    """Lien fractal entre fichiers bas√© sur les imports"""
    
    source_file: str
    target_file: str
    import_type: str  # relative, absolute, external
    link_strength: float = 1.0  # Force du lien (bas√©e sur la fr√©quence)
    
    # Dimensions fractales
    temporal_weight: float = 0.0  # Poids temporel
    complexity_weight: float = 0.0  # Poids de complexit√©
    dependency_weight: float = 0.0  # Poids de d√©pendance
    
    # M√©tadonn√©es temporelles
    created_at: datetime = field(default_factory=datetime.now)
    last_accessed: datetime = field(default_factory=datetime.now)
    access_frequency: int = 0
```

#### 3. **TemporalFractalImportMapper** (Nouvelle classe)
```python
class TemporalFractalImportMapper:
    """Mappeur d'imports fractals temporels"""
    
    def __init__(self, memory_engine: TemporalFractalMemoryEngine):
        self.memory_engine = memory_engine
        self.import_analyzer = PartitioningImportAnalyzer()
        self.fractal_nodes: Dict[str, FractalImportNode] = {}
        self.temporal_graph = TemporalDependencyGraph()
    
    async def fractalize_project_imports(self, project_root: str) -> Dict[str, FractalImportNode]:
        """Transforme les imports du projet en structure fractale temporelle"""
        
        # 1. Analyse des imports
        analysis_result = self.import_analyzer.analyze_imports(
            self._get_project_files(project_root),
            use_import_resolver=True
        )
        
        # 2. Cr√©ation des n≈ìuds fractals
        for file_path, file_data in analysis_result['files_data'].items():
            fractal_node = self._create_fractal_node(file_path, file_data)
            self.fractal_nodes[file_path] = fractal_node
        
        # 3. Cr√©ation des liens temporels
        await self._create_temporal_links(analysis_result['dependencies'])
        
        # 4. Stockage dans le moteur de m√©moire
        await self._store_fractal_imports()
        
        return self.fractal_nodes
    
    def _create_fractal_node(self, file_path: str, file_data: Dict) -> FractalImportNode:
        """Cr√©e un n≈ìud fractal √† partir des donn√©es d'analyse"""
        
        # Calcul de la complexit√© fractale
        complexity = self._calculate_import_complexity(file_data)
        
        # D√©termination de la strate
        strata = self._determine_strata(file_data['depth'], complexity)
        
        return FractalImportNode(
            file_path=file_path,
            dependency_depth=file_data['depth'],
            import_complexity=complexity,
            strata=strata,
            import_patterns=self._extract_import_patterns(file_data['imports'])
        )
    
    async def _create_temporal_links(self, dependencies: List[str]):
        """Cr√©e les liens temporels entre les n≈ìuds fractals"""
        
        for dep in dependencies:
            source, target = self._parse_dependency(dep)
            
            if source in self.fractal_nodes and target in self.fractal_nodes:
                temporal_link = TemporalLink(
                    source_node=self.fractal_nodes[source],
                    target_node=self.fractal_nodes[target],
                    link_type="import_dependency",
                    temporal_weight=self._calculate_temporal_weight(source, target)
                )
                
                self.temporal_graph.add_link(temporal_link)
    
    def _calculate_import_complexity(self, file_data: Dict) -> float:
        """Calcule la complexit√© fractale d'un fichier bas√©e sur ses imports"""
        
        base_complexity = len(file_data['imports'])
        depth_multiplier = 1 + (file_data['depth'] * 0.2)
        import_diversity = len(set(file_data['imports']))
        
        return (base_complexity * depth_multiplier * import_diversity) / 100.0
    
    def _determine_strata(self, depth: int, complexity: float) -> str:
        """D√©termine la strate temporelle bas√©e sur la profondeur et complexit√©"""
        
        if depth <= 1 and complexity < 0.5:
            return "somatic"  # Fichiers simples, peu de d√©pendances
        elif depth <= 3 and complexity < 2.0:
            return "cognitive"  # Fichiers interm√©diaires
        else:
            return "metaphysical"  # Fichiers complexes, profonds
```

### Int√©gration dans TemporalFractalMemoryEngine

#### 1. **Extension de l'API**
```python
class TemporalFractalMemoryEngine:
    """Moteur de m√©moire fractale temporelle avec analyse d'imports"""
    
    def __init__(self, backend_type: str = "auto", **kwargs):
        super().__init__(backend_type, **kwargs)
        self.import_mapper = TemporalFractalImportMapper(self)
        self.fractal_import_graph = None
    
    async def fractalize_project_structure(self, project_root: str) -> Dict[str, Any]:
        """Fractalise la structure compl√®te d'un projet"""
        
        # 1. Analyse des imports
        fractal_nodes = await self.import_mapper.fractalize_project_imports(project_root)
        
        # 2. Cr√©ation de la m√©moire fractale
        project_memory = await self._create_project_fractal_memory(fractal_nodes)
        
        # 3. Indexation temporelle
        await self._index_temporal_dependencies(fractal_nodes)
        
        return {
            'fractal_nodes': fractal_nodes,
            'temporal_graph': self.import_mapper.temporal_graph,
            'project_memory': project_memory
        }
    
    async def query_fractal_imports(self, query: str, strata: str = None) -> List[FractalImportNode]:
        """Interroge la structure fractale des imports"""
        
        # Recherche dans les n≈ìuds fractals
        results = []
        for node in self.fractal_nodes.values():
            if self._matches_query(node, query, strata):
                results.append(node)
        
        return sorted(results, key=lambda n: n.import_complexity, reverse=True)
    
    async def get_import_dependency_path(self, source_file: str, target_file: str) -> List[str]:
        """Trouve le chemin de d√©pendance entre deux fichiers"""
        
        return self.import_mapper.temporal_graph.find_path(source_file, target_file)
```

#### 2. **Nouvelles M√©thodes de Recherche**
```python
class TemporalFractalMemoryEngine:
    
    async def find_circular_dependencies(self) -> List[List[str]]:
        """Trouve les d√©pendances circulaires dans le projet"""
        return self.import_mapper.temporal_graph.detect_cycles()
    
    async def get_most_complex_files(self, limit: int = 10) -> List[FractalImportNode]:
        """Retourne les fichiers les plus complexes"""
        nodes = list(self.fractal_nodes.values())
        return sorted(nodes, key=lambda n: n.import_complexity, reverse=True)[:limit]
    
    async def get_temporal_import_evolution(self, file_path: str) -> Dict[str, Any]:
        """Analyse l'√©volution temporelle des imports d'un fichier"""
        return await self._analyze_temporal_evolution(file_path)
    
    async def suggest_refactoring(self, file_path: str) -> List[str]:
        """Sugg√®re des refactorisations bas√©es sur l'analyse fractale"""
        return await self._generate_refactoring_suggestions(file_path)
```

### Avantages de l'Int√©gration

#### 1. **Cartographie Vivante**
- Visualisation en temps r√©el des d√©pendances
- D√©tection automatique des patterns d'imports
- √âvolution temporelle de la structure

#### 2. **Intelligence Fractale**
- M√©triques de complexit√© bas√©es sur les imports
- Classification automatique en strates temporelles
- D√©tection de patterns r√©currents

#### 3. **Optimisation Continue**
- Suggestions de refactoring automatiques
- D√©tection de d√©pendances circulaires
- Optimisation de la structure du projet

#### 4. **M√©moire Temporelle**
- Historique des changements d'imports
- √âvolution de la complexit√© dans le temps
- Pr√©diction de l'√©volution future

---

## üîß **Impl√©mentation Technique**

### √âtapes de D√©veloppement

#### Phase 1 : Int√©gration de Base
1. **Migration du code** : D√©placer `partitioning_import_analyzer.py` vers `Core/ImportAnalysis/`
2. **Cr√©ation des nouvelles classes** : `FractalImportNode`, `FractalImportLink`
3. **Int√©gration dans TemporalFractalMemoryEngine** : M√©thodes de base

#### Phase 2 : Fonctionnalit√©s Avanc√©es
1. **TemporalDependencyGraph** : Graphe temporel des d√©pendances
2. **M√©triques de complexit√©** : Calculs fractals avanc√©s
3. **API de requ√™te** : Recherche et filtrage

#### Phase 3 : Intelligence Artificielle
1. **Suggestions automatiques** : Refactoring intelligent
2. **Pr√©diction d'√©volution** : Mod√®les pr√©dictifs
3. **Optimisation continue** : Auto-optimisation

### Structure de Fichiers Propos√©e
```
Core/
‚îú‚îÄ‚îÄ ImportAnalysis/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ fractal_import_mapper.py
‚îÇ   ‚îú‚îÄ‚îÄ fractal_import_node.py
‚îÇ   ‚îú‚îÄ‚îÄ temporal_dependency_graph.py
‚îÇ   ‚îî‚îÄ‚îÄ import_complexity_analyzer.py
‚îú‚îÄ‚îÄ TemporalFractalMemoryEngine/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ engine.py (√©tendu)
‚îÇ   ‚îú‚îÄ‚îÄ fractal_import_integration.py
‚îÇ   ‚îî‚îÄ‚îÄ temporal_import_queries.py
```

---

## üìä **M√©triques et KPIs**

### M√©triques de Complexit√©
- **Import Complexity Score** : Complexit√© bas√©e sur le nombre et la diversit√© des imports
- **Dependency Depth** : Profondeur maximale de d√©pendance
- **Circular Dependency Ratio** : Ratio de d√©pendances circulaires
- **Temporal Evolution Rate** : Taux d'√©volution des imports dans le temps

### M√©triques de Performance
- **Analysis Speed** : Vitesse d'analyse des imports
- **Memory Usage** : Utilisation m√©moire pour le stockage fractal
- **Query Response Time** : Temps de r√©ponse des requ√™tes fractales

---

## üéØ **Conclusion**

L'int√©gration de l'analyseur d'imports dans le TemporalFractalMemoryEngine repr√©sente une **√©volution majeure** vers un syst√®me de m√©moire fractale temporelle complet.

### B√©n√©fices Attendus
1. **Compr√©hension profonde** de la structure du projet
2. **Optimisation automatique** des d√©pendances
3. **Pr√©diction d'√©volution** de la complexit√©
4. **Refactoring intelligent** bas√© sur l'analyse fractale